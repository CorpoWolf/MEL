// Script to generate a door with size prompts
// VRChat Profile: https://vrchat.com/home/user/usr_45f42990-f078-4589-9263-3017ae863733
// Twitter Profile: https://twitter.com/SawyerDotWolf


proc sg_doorUI() {
    string $WinName = "PrimeWindow";
    
    if (`window -exists $WinName`) {
        deleteUI $WinName;
    }
    
    window -t "Greythorne Door Generator" -w 300 -h 150 $WinName;
        columnLayout -adj true;
        global string $DrP[]; // Door Parameters
        $DrP[0] = `textFieldGrp -l "Door Width: "`;
        $DrP[1] = `textFieldGrp -l "Door Height: "`;
        $DrP[2] = `textFieldGrp -l "Door Thickness: "`;
        button -l "Generate" -c "sg_doorConstructor";
    showWindow $WinName;
}
sg_doorUI();

proc sg_doorConstructor() {
    global string $DrP[];
    global float $DoorSz[];

    for ($i=0; $i < 3; $i++) {
        $DoorSz[$i] = sg_inchParser($DrP[$i]);
    }

    string $NewDoor[] = `polyCube -w $DoorSz[0] -h $DoorSz[1] -d $DoorSz[2] -n "Door"`;
    move -rpr 0 ($DoorSz[1]/2) 0;
    move -r 0 (-$DoorSz[1]/2) 0 ($NewDoor[0] + ".scalePivot") ($NewDoor[0] + ".rotatePivot");
    print("Door Generated");
    select -r ($NewDoor[0] + ".f[4]");
    doDelete;
    
    GenerateHingeSide();
}

//Right is positive, left is negative : X axis
proc GenerateHingeSide() {
    global float $DoorSz[];

    float $HingePosTop[] = {7.375, 39.3125, 71.25};

    for ($arr = 0; $arr < 3; $arr++) {

        if ($arr == 2) {
            $geoTop = $DoorSz[1] - midLine($HingePosTop[($arr-1)], $HingePosTop[$arr], 4.5);
            $geoHeight = $DoorSz[2] + midLine($HingePosTop[$arr-1], $HingePosTop[$arr], 4.5);
            $geoHingeTop = $HingePosTop[$arr] - $geoHeight;

            float $wh[] = vrtxRNotch($DoorSz[2], $geoHeight, 1.5, 4.5, $geoHingeTop);
            float $xyzCord[] = whXYZ($wh);

            float $offset[] = {inch($DoorSz[0]/2), inch($geoTop), 0};
            float $polyCord[] = vrtxRePosition($xyzCord, $offset);
            FirstPoly($polyCord);
            AppnPoly($polyCord, 1, 4);
            AppnPoly($polyCord, 5, 6);

        } else {
            float $geoTop;
            float $geoHeight;
            float $geoHingeTop;
            if ($arr > 0) {
                $geoTop = $DoorSz[1] - midLine($HingePosTop[($arr-1)], $HingePosTop[$arr], 4.5);
                $geoHeight = midLine($HingePosTop[$arr], $HingePosTop[$arr+1], 4.5) - midLine($HingePosTop[$arr-1], $HingePosTop[$arr], 4.5);
                $geoHingeTop = $HingePosTop[$arr] - $geoHeight;
            } else {
                $geoTop = $DoorSz[1];
                $geoHeight = midLine($HingePosTop[$arr], $HingePosTop[$arr+1], 4.5);
                $geoHingeTop = $HingePosTop[$arr];
            }

            float $wh[] = vrtxRNotch($DoorSz[2], $geoHeight, 1.5, 4.5, $geoHingeTop);
            float $xyzCord[] = whXYZ($wh);

            float $offset[] = {inch($DoorSz[0]/2), inch($geoTop), 0};
            float $polyCord[] = vrtxRePosition($xyzCord, $offset);
            FirstPoly($polyCord);
            AppnPoly($polyCord, 1, 4);
            AppnPoly($polyCord, 5, 6);
        }
    }
}

proc FirstPoly(float $vrts[]) {
    string $cmd = "polyCreateFacet ";
    for ($Macro = 0; $Macro < 4; $Macro++) {
        $cmd += "-p ";

        for ($micro = 0; $micro < 3; $micro++) {
            $cmd += $vrts[$Macro*3 + $micro] + " ";
        }
    }
    print($cmd + "\n");
    eval($cmd);
}

proc AppnPoly(float $vrts[], int $edge, int $newVert) {
    string $cmd = "polyAppend -ch 1 -ed " + $edge;
    for ($Macro = $newVert; $Macro < $newVert + 2; $Macro++) {
        $cmd += "-p ";

        for ($micro = 0; $micro < 3; $micro++) {
            $cmd += $vrts[$Macro*3 + $micro] + " ";
        }
    }
    print($cmd + "\n");
    eval($cmd);
}

proc float[] vrtxRNotch(float $w, float $h, float $nw, float $nh, float $nTop) {

    float $xLn[3];
    float $yLn[4];

    $xLn[0] = $w/2;
    $xLn[1] = $w/2-($w-$nw);
    $xLn[2] = -$w/2;

    $yLn[0] = 0;
    $yLn[1] = -$nTop;
    $yLn[2] = -$nTop - $nh;
    $yLn[3] = -$h;
    
    float $vrtxData[] = {
        $xLn[2], $yLn[0],
        $xLn[0], $yLn[0],
        $xLn[1], $yLn[1],
        $xLn[2], $yLn[1],

        $xLn[0], $yLn[3],
        $xLn[1], $yLn[2],

        $xLn[2], $yLn[3],
        $xLn[2], $yLn[2]
    };
    return $vrtxData;
}

proc float[] whXYZ(float $wh[]) {
    float $xyzCord[];

        for ($arr = 0; $arr < size($wh)/2; $arr++) {
            $xyzCord[$arr*3] = 0; // x always zero
            $xyzCord[$arr*3+2] = inch($wh[$arr*2]); //y = h
            $xyzCord[$arr*3+1] = inch($wh[$arr*2+1]); //z = w
            print("Vert #" + $arr + " | X : " + $xyzCord[$arr*3] + " | Y : " + $wh[$arr*2] + " | Z : " + $wh[$arr*2+1] + "\n");
        }
    return $xyzCord;
}

proc float[] vrtxRePosition(float $origin[], float $translate[]) {
    float $rePosition[];

    for ($arr=0; $arr < (size($origin)/3); $arr++) {
        $rePosition[$arr*3] = $origin[$arr*3] + $translate[0]; // 0,3,6,9
        $rePosition[$arr*3+1] = $origin[$arr*3+1] + $translate[1]; // 1,4,7,10
        $rePosition[$arr*3+2] = $origin[$arr*3+2] + $translate[2]; // 2,5,8,11
    }
    return $rePosition;
}

proc float inch(float $value) {
    return $value * 2.54;
}

proc float midLine(float $posA, float $posB, float $objHeight) {
    return (($posB - ($posA + $objHeight))/2) + ($posA + $objHeight);
}