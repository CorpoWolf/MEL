// Script to generate a door with size prompts
// VRChat Profile: https://vrchat.com/home/user/usr_45f42990-f078-4589-9263-3017ae863733
// Twitter Profile: https://twitter.com/SawyerDotWolf

proc sg_doorUI() {
    string $WinName = "PrimeWindow";
    
    if (`window -exists $WinName`) {
        deleteUI $WinName;
    }
    
    window -t "Greythorne Door Generator" -w 300 -h 150 $WinName;
        columnLayout -adj true;
        global string $DrP[]; // Door Parameters
        $DrP[0] = `textFieldGrp -l "Door Width: "`;
        $DrP[1] = `textFieldGrp -l "Door Height: "`;
        $DrP[2] = `textFieldGrp -l "Door Thickness: "`;
        button -l "Generate" -c "sg_doorConstructor";
    showWindow $WinName;
}
sg_doorUI();

proc sg_doorConstructor() {
    global string $DrP[];
    global float $DoorSz[];

    for ($i=0; $i < 3; $i++) {
        $DoorSz[$i] = sg_inchParser($DrP[$i]);
    }

    string $NewDoor[] = `polyCube -w $DoorSz[0] -h $DoorSz[1] -d $DoorSz[2] -n "Door"`;
    move -rpr 0 ($DoorSz[1]/2) 0;
    move -r 0 (-$DoorSz[1]/2) 0 ($NewDoor[0] + ".scalePivot") ($NewDoor[0] + ".rotatePivot");
    print("Door Generated");
    select -r ($NewDoor[0] + ".f[4]");
    doDelete;
    
    GenerateHingeSide();
}

//Right is positive, left is negative : X axis
proc GenerateHingeSide() {
    global float $DoorSz[];
    float $offset[];

    float $hingeTop[] = {7.375, 39.3125, 71.25};

    for ($arr = 0; $arr < 3; $arr++) {

        if ($arr == 2) {
            $geoTop = $DoorSz[1] - midLine($hingeTop[($arr-1)], $hingeTop[$arr], 4.5);
            $geoHeight = $DoorSz[2] + midLine($hingeTop[$arr-1], $hingeTop[$arr], 4.5);
            $geoHingeTop = $hingeTop[$arr] - $geoHeight;

            float $wh[] = sg_notchRight($DoorSz[2], $geoHeight, 1.5, 4.5, $geoHingeTop);
            float $xyzCord[] = sg_convert2DTo3D($wh);

            $offset[0] = sg_inchVal($DoorSz[0]/2);
            $offset[1] = sg_inchVal($geoTop);
            $offset[2] = 0;
            
            float $polyCord[] = sg_vrtxMove($xyzCord, $offset);
            sg_createPoly($polyCord);
            sg_addPoly($polyCord, 1, 4);
            sg_addPoly($polyCord, 5, 6);

        } else {
            float $geoTop;
            float $geoHeight;
            float $geoHingeTop;
            if ($arr > 0) {
                $geoTop = $DoorSz[1] - midLine($hingeTop[($arr-1)], $hingeTop[$arr], 4.5);
                $geoHeight = midLine($hingeTop[$arr], $hingeTop[$arr+1], 4.5) - midLine($hingeTop[$arr-1], $hingeTop[$arr], 4.5);
                $geoHingeTop = $hingeTop[$arr] - $geoHeight;
            } else {
                $geoTop = $DoorSz[1];
                $geoHeight = midLine($hingeTop[$arr], $hingeTop[$arr+1], 4.5);
                $geoHingeTop = $hingeTop[$arr];
            }

            float $wh[] = sg_notchRight($DoorSz[2], $geoHeight, 1.5, 4.5, $geoHingeTop);
            float $xyzCord[] = sg_convert2DTo3D($wh);

            $offset[0] = sg_inchVal($DoorSz[0]/2);
            $offset[1] = sg_inchVal($geoTop);
            $offset[2] = 0;

            float $polyCord[] = sg_vrtxMove($xyzCord, $offset);
            sg_createPoly($polyCord);
            sg_addPoly($polyCord, 1, 4);
            sg_addPoly($polyCord, 5, 6);
        }
    }
}

proc sg_createPoly(float $vrts[]) {
    string $cmd = "polyCreateFacet ";
    for ($Macro = 0; $Macro < 4; $Macro++) {
        $cmd += "-p ";

        for ($micro = 0; $micro < 3; $micro++) {
            $cmd += $vrts[$Macro*3 + $micro] + " ";
        }
    }
    print($cmd + "\n");
    eval($cmd);
}

proc sg_addPoly(float $vrts[], int $edge, int $newVert) {
    string $cmd = "polyAppend -ch 1 -ed " + $edge;
    for ($Macro = $newVert; $Macro < $newVert + 2; $Macro++) {
        $cmd += "-p ";

        for ($micro = 0; $micro < 3; $micro++) {
            $cmd += $vrts[$Macro*3 + $micro] + " ";
        }
    }
    print($cmd + "\n");
    eval($cmd);
}

proc float[] sg_notchRight(float $w, float $h, float $nw, float $nh, float $nTop) {

    float $xLn[3];
    float $yLn[4];

    $xLn[0] = $w/2;
    $xLn[1] = $w/2-($w-$nw);
    $xLn[2] = -$w/2;

    $yLn[0] = 0;
    $yLn[1] = -$nTop;
    $yLn[2] = -$nTop - $nh;
    $yLn[3] = -$h;
    
    float $vrtxData[] = {
        $xLn[2], $yLn[0],
        $xLn[0], $yLn[0],
        $xLn[1], $yLn[1],
        $xLn[2], $yLn[1],

        $xLn[0], $yLn[3],
        $xLn[1], $yLn[2],

        $xLn[2], $yLn[3],
        $xLn[2], $yLn[2]
    };
    return $vrtxData;
}